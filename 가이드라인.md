# 📰 AI 뉴스레터 자동화 시스템 가이드

## 🎯 이 시스템이 뭘 하나요?

쉽게 말해서 **"매일 아침 8시에 자동으로 뉴스를 정리해서 이메일로 보내주는 로봇"**입니다! 🎉

예를 들어:
1. TLDR라는 뉴스레터가 매일 여러분의 Gmail에 도착합니다
2. 이 시스템이 Gmail에 자동으로 접속해서 오늘 들어온 뉴스를 가져옵니다
3. 그리고 "어제 한 친구가 알아듣기 쉽게 정리해주는" 것처럼 AI(인공지능)가 재미있게 다시 써줍니다
4. 마지막으로 여러분에게 예쁘게 정리된 이메일을 보내줍니다!

→ **결과: 매일 아침 깔끔하게 정리된 AI 뉴스를 받을 수 있어요!** 📬

---

## 📁 각 파일은 무슨 일을 하나요?

생각하시면 **"요리 레시피"**와 비슷해요. 각 파일이 다른 역할을 합니다!

### 1️⃣ `main.py` - 메인 요리사 👨‍🍳
- **역할**: 모든 일을 처리하는 핵심 프로그램
- **하는 일**: Gmail 접속 → 뉴스 읽기 → AI에게 요약 요청 → 이메일 보내기
- **비유**: 레스토랑의 셰프처럼 모든 요리를 담당합니다

### 2️⃣ `config.py` - 요리 재료 보관함 🍱
- **역할**: 중요한 정보들(Gmail 비밀번호, AI API 키 등)을 저장
- **주의**: 이 파일은 절대 공유하면 안 됩니다! (비밀번호 같은 거니까요)

**주요 내용:**
```python
GMAIL_EMAIL = "여러분의 Gmail 주소"
GMAIL_APP_PASSWORD = "Gmail 앱 비밀번호"
RECIPIENT_EMAILS = ["받는 사람 이메일들"]
AZURE_OPENAI_ENDPOINT = "AI 서버 주소"
```

### 3️⃣ `requirements.txt` - 필요한 도구 목록 📦
- **역할**: 이 프로그램이 동작하는데 필요한 "도구들" 리스트
- **예시**: 
  - beautifulsoup4: HTML 읽는 도구
  - openai: GPT모델 API 호출!
  - lxml: 웹페이지 해석 도구

💡 **참고**: 이 프로젝트에는 `Dockerfile`과 Kubernetes 설정 파일들도 있지만, 배포는 별도로 `배포가이드.md`를 참고하세요!

---

## 🚀 이 시스템이 동작하는 과정 (단계별 설명)

### 1단계: Gmail 접속해서 뉴스 찾기 📧
```python
def connect_gmail()  # Gmail에 "로그인"하는 함수
def search_recent_emails()  # 최근 메일 찾는 함수
```

**쉽게 설명하면:**
- 여러분이 스마트폰으로 Gmail 앱을 켜는 것과 똑같습니다!
- 단지 사람 대신 "로봇"이 자동으로 하는 거예요

### 2단계: HTML에서 뉴스 기사 추출하기 📰
```python
def extract_articles_from_html()  # 웹페이지에서 기사 찾기
```

**쉽게 설명하면:**
- 신문에서 "중요한 기사"만 골라서 오려내는 것처럼
- HTML이라는 웹페이지 코드에서 제목, 요약, 링크만 뽑아냅니다

**HTML이 뭐냐구요?**
- 웹페이지를 만드는 "언어"예요
- 예를 들어: `<h1>제목</h1>` → 제목 표시
- 프로그램이 이걸 읽어서 "어? 여기 제목이네!" 하고 찾아냅니다

**🔍 뉴스레터 파싱 방법 (중요!)**

#### 1. 개발자 도구로 태그 확인
먼저 TLDR 뉴스레터를 열어서:
1. Google Chrome으로 메일 열기
2. F12 키 누르기 (개발자 도구 열림)
3. Elements 탭에서 HTML 구조 확인

**예시:**
```html
<table>
  <a href="https://example.com">
    <strong>이게 제목이네요!</strong>  ← 이 태그를 찾아야 함!
  </a>
  <span>이게 요약입니다</span>
</table>
```

#### 2. 어떤 태그가 "제목"인지 확인
- TLDR 뉴스레터: `<strong>` 태그 안에 제목이 있음
- 다른 뉴스레터는 다를 수 있음: `<h2>`, `<h3>`, `<p>` 등
- **⚠️ 절대 가정하지 말고 확인 후 코딩!**

#### 3. 코드에 반영
```python
# TLDR은 <strong> 태그 사용
strong_tag = link_tag.find('strong')
title = strong_tag.get_text(strip=True)
```

**다른 뉴스레터를 쓸 거라면:**
- 반드시 개발자 도구로 태그 확인
- 그 태그에 맞게 `main.py` 수정 필수!

### 3단계: AI에게 요약 요청하기 🤖
```python
def summarize_articles()  # AI에게 "이 뉴스 재미있게 써줘" 요청
```

**쉽게 설명하면:**
- ChatGPT에게 "이 뉴스 읽고 친구한테 설명하듯 써줘"라고 부탁하는 것
- 여기서는 Azure OpenAI(마이크로소프트의 ChatGPT)를 사용합니다

**AI에게 보내는 명령:**
```
프롬프트: "이 뉴스들을 친구한테 말하듯 재미있게 써줘
- 이모지 많이 써줘 (🎉🔥💡)
- 쉬운 말로 설명해줘
- 숫자는 강조해줘"
```

### 4단계: 예쁘게 꾸며서 이메일 보내기 💌
```python
def send_summary_email()  # 정리된 뉴스를 예쁜 이메일로 보내기
```

**쉽게 설명하면:**
- 페인트 프로그램에서 색 칠하기 하는 것처럼
- HTML으로 예쁜 색깔, 크기, 버튼을 만듭니다
- 그리고 여러분에게 이메일로 발송!

---

## 🎨 시스템 구조 (전체 그림)

```
┌─────────────────────────────────────────────────────┐
│                    매일 아침 8시                    │
│                   CronJob 깨어남                    │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
      ┌──────────────────────┐
      │  1. Gmail 접속       │ ← config.py에서 비밀번호 가져옴
      │     (IMAP 서버)      │
      └──────────┬───────────┘
                 │
                 ▼
      ┌──────────────────────┐
      │  2. TLDR 메일 찾기    │ ← 최근 3일 내 메일 (주말 제외)
      │     (시간대 고려!)    │
      └──────────┬───────────┘
                 │
                 ▼
      ┌──────────────────────┐
      │  3. HTML 파싱         │ ← BeautifulSoup으로 기사 추출
      │     (기사만 골라내기)  │
      └──────────┬───────────┘
                 │
                 ▼
      ┌──────────────────────┐
      │  4. AI에게 요약 요청   │ ← Azure OpenAI API 호출
      │     (한국어로 재작성)  │
      └──────────┬───────────┘
                 │
                 ▼
      ┌──────────────────────┐
      │  5. HTML 꾸미기       │ ← 색깔, 버튼, 레이아웃
      └──────────┬───────────┘
                 │
                 ▼
      ┌──────────────────────┐
      │  6. 이메일 발송       │ ← SMTP로 여러 명에게 발송
      └──────────────────────┘
```

---

## ⚙️ 세부 기능 설명 (고급)

### 1. IMAP이 뭔가요?
- **인터넷 메일 프로토콜**: 이메일을 읽는 표준 방법
- 여러분이 "네이버 메일" 앱을 쓰는 것처럼, 프로그램도 IMAP을 통해 Gmail을 읽습니다
- Google이 제공하는 공식 방법이에요!

### 2. BeautifulSoup은?
- **HTML/XML 파서**: 웹페이지 구조를 읽고 분석하는 도구
- 예를 들어:
  ```html
  <table>
    <a href="링크">
      <strong>제목</strong>
    </a>
    <span>요약</span>
  </table>
  ```
  → BeautifulSoup이 이걸 읽어서 "어? 여기 제목이고, 여기 링크고, 여기가 요약이네!" 하고 찾아줍니다!

### 3. Azure OpenAI?
- **Microsoft의 AI 서비스**: ChatGPT와 비슷하지만 회사에서 안전하게 쓸 수 있는 버전
- **Deployment**: 모델이 실제로 살고 있는 "집 주소"
- **API Key**: AI 서비스에 접근할 수 있는 "열쇠"

### 4. SMTP는?
- **Simple Mail Transfer Protocol**: 이메일을 보내는 표준 방법
- Gmail의 SMTP 서버(smtp.gmail.com)를 통해 이메일을 발송합니다

### 5. CronJob?
- **크론 스케줄러**: 리눅스/유닉스에서 "정해진 시간에 명령 실행"하는 도구
- `0 23 * * *` 의미:
  ```
  0: 0분
  23: 23시 (UTC 기준)
  *: 매일
  *: 매월
  *: 매년
  → "매일 UTC 23시(KST 오전 8시)마다 실행"
  ```

---

## 🔧 설정 방법 (Step by Step)

### Step 1: Python 환경 준비
```bash
# 파이썬이 설치되어 있는지 확인
python3 --version

# 가상환경 만들기
python3 -m venv venv

# 가상환경 활성화
source venv/bin/activate  # Mac/Linux
# 또는
.\venv\Scripts\activate  # Windows
```

**쉽게 설명하면:**
- 가상환경은 "프로그램 연습 공간"입니다
- 여기서 프로그램을 실행해도 다른 컴퓨터는 영향받지 않아요

### Step 2: 필요한 도구 설치
```bash
pip install -r requirements.txt
```

**뭐가 설치되나요?**
- beautifulsoup4: HTML 읽기
- lxml: 웹페이지 분석
- openai: AI API 사용
- httpx: 인터넷 통신

### Step 3: Gmail 앱 비밀번호 생성 🔐

**왜 앱 비밀번호가 필요하나요?**
- 일반 Gmail 비밀번호로는 프로그램이 접근할 수 없어요!
- Google이 보안을 위해 "앱 전용 비밀번호"를 따로 만들어야 합니다
- 이 비밀번호는 16자리 숫자+문자 조합입니다

#### 3-1. 2단계 인증 먼저 켜기 (필수!)

먼저 2단계 인증이 꺼져 있으면 앱 비밀번호를 만들 수 없어요!

1. **Google 계정 페이지 접속**
   - https://myaccount.google.com 접속
   - 또는 Gmail → 프로필 사진 → Google 계정 관리

2. **보안 메뉴로 이동**
   - 왼쪽 메뉴에서 "보안" 클릭

3. **2단계 인증 찾기**
   - "Google에 로그인" 섹션 찾기
   - "2단계 인증" 항목 찾기

4. **2단계 인증 켜기**
   - "2단계 인증" 클릭
   - "시작하기" 버튼 클릭
   - 전화번호 입력하고 인증 코드 받기
   - 코드 입력하면 완료!

💡 **팁**: 2단계 인증이 이미 켜져 있다면 이 단계는 건너뛰세요!

#### 3-2. 앱 비밀번호 생성하기

이제 앱 비밀번호를 만들 수 있어요!

1. **앱 비밀번호 페이지로 이동**
   - 방법 1: https://myaccount.google.com/apppasswords 직접 접속
   - 방법 2: Google 계정 → 보안 → 2단계 인증 → 맨 아래 "앱 비밀번호" 클릭

2. **앱 선택**
   - "앱 선택" 드롭다운 클릭
   - "기타(맞춤 이름)" 선택
   - 이름 입력: "뉴스레터 자동화" (원하는 이름 아무거나)

3. **생성 버튼 클릭**
   - "만들기" 버튼 클릭

4. **비밀번호 복사하기**
   - 16자리 비밀번호가 나타납니다!
   - 형식: `xxxx xxxx xxxx xxxx` (공백 포함)
   - **⚠️ 지금 복사하세요!** 나중에 다시 볼 수 없어요!

**예시 화면:**
```
┌─────────────────────────────────────┐
│  앱 비밀번호 생성됨                  │
│                                     │
│  비밀번호:                          │
│  abcd efgh ijkl mnop                │ ← 이걸 복사!
│                                     │
│  ⚠️ 이 비밀번호는 지금만 표시됩니다  │
│                                     │
│  [확인] [복사]                      │
└─────────────────────────────────────┘
```

5. **안전하게 보관하기**
   - 복사한 비밀번호를 메모장이나 비밀번호 관리 앱에 저장
   - 다음 단계에서 `config.py`에 입력할 거예요!

**⚠️ 중요 주의사항:**
- 이 비밀번호는 **한 번만 보여줍니다**! 잃어버리면 다시 만들어야 해요
- 일반 Gmail 비밀번호와는 **완전히 다른 비밀번호**입니다
- 다른 사람에게 공유하지 마세요!
- 이 비밀번호는 Gmail에 로그인하는 게 아니라, 프로그램이 메일을 읽을 때만 사용해요

**문제가 생겼다면?**
- "앱 비밀번호" 메뉴가 안 보여요 → 2단계 인증이 꺼져 있는지 확인!
- "이 기능을 사용할 수 없습니다" → Google Workspace 계정은 관리자가 허용해야 할 수 있어요
- 비밀번호를 잃어버렸어요 → 앱 비밀번호 페이지에서 삭제 후 새로 만들면 됩니다

### Step 4: config.py 설정
```python
# 예시
GMAIL_EMAIL = "abc@gmail.com"
GMAIL_APP_PASSWORD = "xxxx xxxx xxxx xxxx"  # 위 Step 3에서 만든 16자리 앱 비밀번호
RECIPIENT_EMAILS = ["받는이@company.com"]
AZURE_OPENAI_ENDPOINT = "https://xxx.openai.azure.com"
AZURE_OPENAI_API_KEY = "your-api-key"
AZURE_OPENAI_DEPLOYMENT_NAME = "gpt-4o-mini"
AZURE_OPENAI_API_VERSION = "2024-02-15-preview"
```

**주의사항:**
- 앱 비밀번호는 위 Step 3에서 만든 것을 사용하세요!
- 공백 포함 여부는 상관없어요 (`"xxxx xxxx xxxx xxxx"` 또는 `"xxxxxxxxxxxxxxxx"` 둘 다 OK)
- API Key는 절대 공유하지 마세요!

### Step 5: 실행해보기
```bash
python main.py
```

**출력 예시:**
```
추출된 기사 수: 15
Azure OpenAI로 기사 요약 시작...
✅ 요약 메일이 발송되었습니다!
```

💡 **참고**: 실제 운영 환경에 배포하려면 `배포가이드.md`를 참고하세요!

---

## 📖 중요 개념 설명

### 1. 왜 3일치 메일을 읽을까요? (72시간)

**문제 상황:**
- TLDR 뉴스레터는 **주말(토요일/일요일)에 발송되지 않습니다**
- 평일 오전 8시에 시스템이 실행됨

**예시:**
- **금요일**: TLDR 발송 (금요일 메일)
- **토요일**: 발송 없음
- **일요일**: 발송 없음
- **월요일**: 시스템 실행! → 금요일 메일을 찾아야 함

**해결 방법:**
- 24시간만 찾으면 → 월요일에는 금요일 메일을 못 찾음
- 48시간만 찾으면 → 일요일/월요일 경계에서 문제 발생
- **72시간(3일)으로 설정** → 확실하게 최근 평일 메일 찾기 가능!

**최신 메일만 처리:**
```python
# 가장 마지막(=최신) 메일만 선택
latest_email_id = email_ids[-1]
```

### 2. 시간대(Timezone) 주의사항 ⏰

**문제:**
- 한국(KST): UTC+9 (한국은 UTC보다 9시간 빠름)
- 미국 서버: UTC 기준

**예시:**
- 한국 시간 오전 8시 = UTC 23시 (전날 밤 11시)
- CronJob 설정: `0 23 * * *` → 한국 기준 오전 8시

**주의할 점:**
- Gmail 서버는 UTC 기준으로 메일 타임스탬프 저장
- 72시간 계산 시 어떤 기준인지 확인 필수
- `datetime.now()`는 서버 시간 기준!

**✅ 해결책:**
```python
# 한국 시간대 명시적으로 지정
KST = timezone(timedelta(hours=9))
now_kst = datetime.now(KST)
```

### 3. table vs div, 언제 뭘 써야 할까?

#### `<table>` 태그 사용하는 이유

**배경:**
- 이 시스템은 KT DS 사내 메신저에서 이메일을 확인함
- 사내 메신저는 브라우저 내에서 이메일 렌더링

**문제:**
- 최신 웹 기술(`div`, `flexbox` 등)을 사용하면?
- 사내 메신저에서 레이아웃이 깨질 수 있음
- 특히 복잡한 스타일은 제대로 안 나올 수 있음

**해결:**
- **Old-school 방법인 `<table>` 사용**
- table은 1990년대부터 지원된 표준
- 거의 모든 환경에서 안정적으로 작동

**코드 예시:**
```html
<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td>내용</td>
  </tr>
</table>
```

#### 인라인 스타일을 사용하는 이유

**배경:**
- 이메일 클라이언트는 보안상의 이유로 JavaScript와 외부 CSS 차단

**문제:**
```html
<!-- 이렇게 하면 안 됨! -->
<link rel="stylesheet" href="style.css">
<style>
  p { color: blue; }
</style>
```
- 대부분의 이메일 클라이언트가 무시함

**해결:**
```html
<!-- 이렇게 해야 함! -->
<p style="color: blue; font-size: 16px;">
  직접 태그 안에 작성
</p>
```

**왜 하드코딩하나요?**
- 사내 메신저가 인라인 스타일만 제대로 인식
- 복잡한 CSS 파일은 읽지 못함
- **결론**: 각 태그마다 style 속성으로 직접 작성

### 4. HTML 파싱의 핵심: 태그 확인!

**왜 태그를 확인해야 하나요?**

#### 일반적인 착각:
- "뉴스레터 = 제목이 항상 `<h2>` 태그일 거야"
- **❌ 절대 그런 보장 없음!**

#### 실제 상황:
- **TLDR**: `<strong>` 태그 사용
- **TechCrunch**: `<h2>` 태그 사용
- **Hacker News**: `<h3>` 태그 사용
- **각 뉴스레터마다 다름!**

#### 개발자 도구(F12)로 확인하는 방법:

1. **메일 열기**
   - Chrome에서 TLDR 뉴스레터 메일 열기

2. **개발자 도구 열기**
   - F12 키 누르기
   - 또는 우클릭 → "검사(Inspect)"

3. **HTML 구조 확인**
   - Elements 탭 클릭
   - 제목 부분에 마우스 올리기
   - 아래 코드 보기

**예시:**
```html
<table align="center">
  <tr>
    <td>
      <a href="https://example.com">
        <strong style="...">  ← 여기가 제목!
          OpenAI가 새로운 모델 출시
        </strong>
      </a>
      <br><br>
      <span style="font-family:...">  ← 여기가 요약!
        오픈AI가 GPT-5를 발표했습니다...
      </span>
    </td>
  </tr>
</table>
```

4. **코드에 반영**
   ```python
   # TLDR은 <strong> 태그 사용
   strong_tag = link_tag.find('strong')
   title = strong_tag.get_text(strip=True)
   
   # 다른 뉴스레터라면 이렇게 바꿔야 함!
   # h2_tag = link_tag.find('h2')
   # title = h2_tag.get_text(strip=True)
   ```

**다른 뉴스레터를 적용하려면:**
1. 개발자 도구로 태그 확인
2. 해당 태그에 맞게 `extract_articles_from_html()` 함수 수정
3. BeautifulSoup의 `find()` 메서드 사용법만 알면 됨!

---

## 🐛 문제 해결 가이드

### 1. "Gmail 연결 실패" 에러
**원인:**
- 앱 비밀번호가 틀렸거나
- Gmail 2단계 인증이 안 되어 있거나
- 인터넷 연결 문제

**해결:**
```bash
# Google 계정 → 보안 → 2단계 인증 ON
# 앱 비밀번호 다시 생성
# config.py 확인
```

### 2. "메일을 찾을 수 없음" 에러
**원인:**
- TLDR 메일이 수신되어 있지 않거나
- TLDR_SENDER_EMAILS 설정이 잘못됨

**해결:**
```python
# config.py 확인
TLDR_SENDER_EMAILS = ["dan@tldrnewsletter.com"]
```

### 3. "Azure OpenAI 오류"
**원인:**
- API 키가 잘못됨
- 엔드포인트 URL 틀림
- Deployment 이름 잘못됨

**해결:**
```python
# config.py에서 확인
AZURE_OPENAI_ENDPOINT = "https://xxx.openai.azure.com"  # 끝에 / 없어야 함!
AZURE_OPENAI_API_KEY = "올바른 키"
AZURE_OPENAI_DEPLOYMENT_NAME = "gpt-4o-mini"  # 올바른 모델명
```

### 4. "HTML 파싱 실패"
**원인:**
- TLDR 뉴스레터 HTML 구조가 바뀜
- BeautifulSoup이 기사를 못 찾음

**해결:**
```python
# main.py의 extract_articles_from_html() 함수 수정
# HTML 구조에 맞게 코드 수정 필요
```

---

## 🎓 주요 함수 설명 (고급자용)

### `connect_gmail()` - Gmail 로그인
- **역할**: Gmail 서버에 접속하여 메일 읽기 준비
- **사용 기술**: imaplib (Python의 이메일 라이브러리)

### `search_recent_emails()` - 최근 메일 검색
- **역할**: 최근 N시간 내 특정 발신자의 메일만 찾기
- **검색 쿼리**: `(SINCE 날짜 FROM 발신자)`
- **특이사항**: 최근 72시간(3일) 검색하는 이유?
  - TLDR 뉴스레터는 **주말에 발송되지 않음** (토요일/일요일 제외)
  - 평일 월요일 아침에 실행할 때, 금요일 메일을 찾기 위해 3일치를 확인
  - 가장 최신 메일만 처리하여 중복 발송 방지
- **⚠️ 시간대 주의**: 한국(KST)과 미국(UTC) 시간대 차이 고려 필수!

### `extract_articles_from_html()` - 기사 추출
- **역할**: HTML에서 제목, 요약, 링크만 뽑아내기
- **사용 기술**: BeautifulSoup
- **필터링**: Sponsor 광고 제외, 중복 제거
- **📌 핵심**: HTML 구조 파악 필요!
  - 먼저 개발자도구(F12)로 TLDR 뉴스레터 열기
  - 뉴스 제목이 어떤 태그로 감싸져 있는지 확인 (예: `<strong>`)
  - 해당 태그를 기준으로 파싱 코드 작성
  - **다른 뉴스레터 사용 시 반드시 태그 확인 후 수정 필수!**

### `summarize_articles()` - AI 요약
- **역할**: 추출한 기사를 AI에게 보내서 재미있게 재작성 요청
- **프롬프트 엔지니어링**: AI에게 잘 부탁하는 기술
- **스타일**: 구어체, 이모지 활용, 친근한 톤

### `format_ai_html()` - HTML 꾸미기
- **역할**: AI가 만든 내용을 예쁘게 스타일링
- **사용 기술**: 정규식(regex) + HTML/CSS
- **효과**: 색상, 글꼴, 레이아웃 추가

### `send_summary_email()` - 메일 발송
- **역할**: 최종 결과를 HTML 이메일로 보내기
- **사용 기술**: smtplib (Python의 메일 발송 라이브러리)
- **형식**: MIMEMultipart (HTML + 텍스트)

---

## 📊 데이터 흐름 (고급자용)

```
Gmail 메일
  ↓ (IMAP 읽기)
HTML 본문
  ↓ (BeautifulSoup 파싱)
기사 리스트 [{title, summary, link}, ...]
  ↓ (Azure OpenAI API 호출)
한국어 요약 텍스트
  ↓ (HTML 스타일링)
최종 HTML 이메일
  ↓ (SMTP 발송)
수신자들 📬
```

---

## 🎨 HTML 스타일링 원리

### AI에게 요청하는 스타일:
```
<h2>제목+이모지</h2>
<p>흥미유발 인트로</p>
<p>핵심내용 <strong>숫자</strong> 강조</p>
```

### 실제 변환 과정:
```python
# AI가 반환한 HTML
<h2>안녕하세요</h2>

# 자동으로 스타일 추가
<h2 style="color: #2196F3; padding: 12px; ...">안녕하세요</h2>
```

### 주요 스타일 요소:
1. **색상**: 각 섹션별 다른 색 (파란색, 주황색 등)
2. **버튼**: 링크를 클릭하기 쉬운 버튼으로 변환
3. **강조**: `<strong>` 태그를 노란 배경으로 강조
4. **레이아웃**: 읽기 편한 간격과 정렬

### 🤔 왜 특별한 방식을 사용할까요?

#### 1. `<table>` 태그를 사용하는 이유
- **일반적으로**: 요즘은 `<div>`를 더 많이 사용
- **왜 table인가?**: KT DS 사내 메신저 호환성 때문!
- **사정**: 사내 메신저는 브라우저 내에서 이메일을 보여주는데, table 구조가 훨씬 안정적
- **결과**: 레이아웃이 깨지지 않고 제대로 보임

#### 2. 인라인 스타일을 사용하는 이유
- **일반적으로**: CSS 파일을 따로 만들어서 적용
- **왜 인라인인가?**: 사내 메신저가 외부 CSS를 제대로 읽지 못함
- **인라인 스타일**: `<p style="color: blue;">` 이렇게 태그 안에 바로 적는 방식
- **결과**: 색깔, 크기, 배경 등이 제대로 표시됨

**📝 핵심**: 사내 환경에 맞춰 기술 선택! 호환성을 최우선으로 고려

---

## 🔐 보안 주의사항

### 절대 하지 말아야 할 것:
1. ❌ `config.py`를 공유하지 마세요 (비밀번호 포함)
2. ❌ API Key를 GitHub에 업로드하지 마세요
3. ❌ 평소 Gmail 비밀번호를 사용하지 마세요 (앱 비밀번호 사용!)

### 올바른 방법:
1. ✅ `.gitignore`에 `config.py` 추가
2. ✅ 앱 비밀번호만 사용 (2단계 인증 필수)
3. ✅ 비밀번호와 API 키는 절대 공유하지 않기

---

## 📝 로그 확인 방법

### 로그 파일 위치:
```
logs/newsletter_summary.log
```

### 로그 확인 명령:
```bash
# 실시간 로그 보기
tail -f logs/newsletter_summary.log

# 최근 20줄만 보기
tail -20 logs/newsletter_summary.log

# 에러만 찾기
grep "ERROR" logs/newsletter_summary.log
```

### 로그 내용 예시:
```
2025-01-15 08:00:00 - INFO - Gmail 연결 성공
2025-01-15 08:00:05 - INFO - 발신자 dan@tldrnewsletter.com에서 3개 메일 검색됨
2025-01-15 08:00:10 - INFO - 추출된 기사 수: 12
2025-01-15 08:00:15 - INFO - Azure OpenAI 요약 완료
2025-01-15 08:00:20 - INFO - 메일 발송 완료: recipient@company.com
```

---

## 🚀 향후 개선 사항

### 현재 버전의 제한사항:
- ❌ 처리된 메일 추적 안 함 (중복 실행 시 문제)
- ❌ 에러 발생 시 재시도 로직 없음
- ❌ 다른 뉴스레터 소스 미지원

### 개선 가능한 부분:
1. **DB 추가**: 처리한 메일 기록 (중복 방지)
2. **재시도 로직**: 실패 시 3번 재시도
3. **다양한 소스**: Hacker News, TechCrunch 등
4. **대시보드**: 발송 이력 확인 웹페이지

---

## 🎓 마무리

이 시스템은 **"반복 작업을 자동화"**하는 전형적인 예시입니다!

### 핵심 개념 정리:
- **API**: 다른 프로그램과 대화하는 방법
- **파싱**: 웹페이지에서 필요한 정보만 추출
- **크론잡**: 정해진 시간에 자동 실행
- **스케줄링**: 자동화의 핵심

### 배운 것:
✅ Gmail IMAP으로 메일 읽기
✅ HTML 파싱으로 기사 추출
✅ AI API로 내용 재작성
✅ 이메일 자동 발송
✅ 자동화 시스템 구축

---

## 📞 문의 사항

문제가 생기면:
1. 로그 파일 확인 (`logs/newsletter_summary.log`)
2. config.py 설정 확인
3. Google 계정 보안 설정 확인

**좋은 하루 되세요!** ✨

